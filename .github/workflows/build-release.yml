name: Build and Release
on:
  push:
    tags:
      - 'v*.*.*'  # Run only when a tag is pushed with semantic versioning format
  workflow_dispatch:  # Allow manual dispatch

jobs:
  build:
    runs-on: windows-latest
    
    env:
      Solution_Name: CodeSplitter.sln
      Configuration: Release
      Platform: x64
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags and branches
        
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup MSBuild Path
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows SDK
      uses: GuillaumeFalourd/setup-windows10-sdk-action@v1
      with:
        sdk-version: 22621
        
    - name: Install Windows App SDK
      run: |
        # Using Windows App SDK version from project file
        $windowsAppSdkUrl = "https://aka.ms/windowsappsdk/1.6/1.6.250205002/windowsappruntimeinstall-x64.exe"
        $installerPath = "windowsappruntimeinstall-x64.exe"
        
        Write-Host "Downloading Windows App SDK from $windowsAppSdkUrl"
        $WebClient = New-Object System.Net.WebClient
        $WebClient.DownloadFile($windowsAppSdkUrl, $installerPath)
        
        Write-Host "Installing Windows App SDK"
        $process = Start-Process -FilePath $installerPath -ArgumentList "--quiet" -Wait -PassThru
        if ($process.ExitCode -ne 0) {
          Write-Error "Windows App SDK installation failed with exit code $($process.ExitCode)"
          exit 1
        }
        Write-Host "Windows App SDK installed successfully"
      shell: pwsh
      
    - name: Restore NuGet packages
      run: |
        Write-Host "Restoring NuGet packages for ${{ env.Solution_Name }}"
        nuget restore ${{ env.Solution_Name }}
        if ($LASTEXITCODE -ne 0) {
          Write-Error "NuGet restore failed with exit code $LASTEXITCODE"
          exit 1
        }
      shell: pwsh
      
    - name: Set Version Number in AppxManifest
      run: |
        $tag = "${{ github.ref_name }}"
        # Remove 'v' prefix if present
        if ($tag.StartsWith('v')) {
          $tag = $tag.Substring(1)
        }
        
        $manifestPath = "Package.appxmanifest"
        Write-Host "Setting version to $tag.0 in $manifestPath"
        
        if (-not (Test-Path $manifestPath)) {
          Write-Error "AppxManifest file not found at $manifestPath"
          exit 1
        }
        
        $manifest = [xml](Get-Content $manifestPath)
        $manifest.Package.Identity.Version = "$tag.0"
        $manifest.Save($manifestPath)
        
        Write-Host "Version updated successfully"
      shell: pwsh
      if: startsWith(github.ref, 'refs/tags/v')
      
    - name: Build solution
      run: |
          msbuild /p:Configuration=${{ env.Configuration }} `
            /p:Platform="${{ env.Platform }}" `
            /p:AppxPackageDir="AppPackages\" `
            /p:AppxBundle=Always `
            /p:UapAppxPackageBuildMode=StoreUpload `
            /p:AppxBundlePlatforms="${{ env.Platform }}" `
            /p:GenerateAppxPackageOnBuild=true `
            /p:SelfContained=true `
            ${{ env.Solution_Name }}
                
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          # Verify that MSIX package was created
          $msixCount = (Get-ChildItem -Path "AppPackages\" -Filter "*.msix*" -Recurse).Count
          Write-Host "Found $msixCount MSIX package(s) in output directory"
          if ($msixCount -eq 0) {
            Write-Error "No MSIX packages were generated during build"
            exit 1
          }
      shell: pwsh
      
    - name: Create MSI installer with Advanced Installer
      run: |
        # Install Advanced Installer CLI
        Write-Host "Installing Advanced Installer via Chocolatey"
        choco install advanced-installer -y
        
        # Find the Advanced Installer executable - the installation location is shown in the logs
        $advinstPath = "C:\Program Files (x86)\Caphyon\Advanced Installer 22.5\bin\x86\advinst.exe"
        
        Write-Host "Checking for Advanced Installer at: $advinstPath"
        if (-not (Test-Path $advinstPath)) {
          # Search for the executable
          Write-Host "Searching for Advanced Installer executable..."
          $advinstPath = Get-ChildItem -Path "C:\Program Files (x86)" -Recurse -Filter "advinst.exe" | 
                         Select-Object -First 1 -ExpandProperty FullName
          
          if (-not $advinstPath) {
            Write-Error "Could not find Advanced Installer executable"
            exit 1
          }
        }
        
        Write-Host "Found Advanced Installer at: $advinstPath"
        
        # Get version from tag
        $version = "${{ github.ref_name }}"
        if (-not $version -or $version -eq '') { $version = "1.0.0" }
        if ($version.StartsWith('v')) { $version = $version.Substring(1) }
        
        Write-Host "Creating MSI for version $version"
        
        # Find the MSIX package
        $msixPath = Get-ChildItem -Path "AppPackages\" -Filter "*.msix" -Recurse | 
                    Select-Object -First 1 -ExpandProperty FullName
        
        if (-not $msixPath) {
          Write-Error "No MSIX package found in build output"
          exit 1
        }
        Write-Host "Found MSIX package at: $msixPath"
        
        # Create MSI directly from MSIX using simple command
        $msiPath = ".\CodeFileSplitter-$version.msi"
        Write-Host "Creating MSI at: $msiPath"
        
        & $advinstPath /msixToMsi "$msixPath" "$msiPath"
        
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to convert MSIX to MSI"
          exit 1
        }
        
        if (-not (Test-Path $msiPath)) {
          Write-Error "MSI file wasn't created at expected location"
          exit 1
        }
        
        Write-Host "MSI installer created successfully: $msiPath"
      shell: pwsh
      
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        name: Code File Splitter ${{ github.ref_name }}
        files: CodeFileSplitter-*.msi
        draft: false
        prerelease: false
        generate_release_notes: true
      if: startsWith(github.ref, 'refs/tags/')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
