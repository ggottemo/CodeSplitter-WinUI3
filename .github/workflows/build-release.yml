name: Build and Release
on:
  push:
    tags:
      - 'v*.*.*'  # Run only when a tag is pushed with semantic versioning format
  workflow_dispatch:  # Allow manual dispatch

jobs:
  build:
    runs-on: windows-latest
    
    env:
      Solution_Name: CodeSplitter.sln
      Configuration: Release
      Platform: x64
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags and branches
        
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup MSBuild Path
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows SDK
      uses: GuillaumeFalourd/setup-windows10-sdk-action@v1
      with:
        sdk-version: 22621
        
    - name: Install Windows App SDK
      run: |
        # Using Windows App SDK version from project file
        $windowsAppSdkUrl = "https://aka.ms/windowsappsdk/1.6/1.6.250205002/windowsappruntimeinstall-x64.exe"
        $installerPath = "windowsappruntimeinstall-x64.exe"
        
        Write-Host "Downloading Windows App SDK from $windowsAppSdkUrl"
        $WebClient = New-Object System.Net.WebClient
        $WebClient.DownloadFile($windowsAppSdkUrl, $installerPath)
        
        Write-Host "Installing Windows App SDK"
        $process = Start-Process -FilePath $installerPath -ArgumentList "--quiet" -Wait -PassThru
        if ($process.ExitCode -ne 0) {
          Write-Error "Windows App SDK installation failed with exit code $($process.ExitCode)"
          exit 1
        }
        Write-Host "Windows App SDK installed successfully"
      shell: pwsh
      
    - name: Restore NuGet packages
      run: |
        Write-Host "Restoring NuGet packages for ${{ env.Solution_Name }}"
        nuget restore ${{ env.Solution_Name }}
        if ($LASTEXITCODE -ne 0) {
          Write-Error "NuGet restore failed with exit code $LASTEXITCODE"
          exit 1
        }
      shell: pwsh
      
    - name: Set Version Number in AppxManifest
      run: |
        $tag = "${{ github.ref_name }}"
        # Remove 'v' prefix if present
        if ($tag.StartsWith('v')) {
          $tag = $tag.Substring(1)
        }
        
        $manifestPath = "Package.appxmanifest"
        Write-Host "Setting version to $tag.0 in $manifestPath"
        
        if (-not (Test-Path $manifestPath)) {
          Write-Error "AppxManifest file not found at $manifestPath"
          exit 1
        }
        
        $manifest = [xml](Get-Content $manifestPath)
        $manifest.Package.Identity.Version = "$tag.0"
        $manifest.Save($manifestPath)
        
        Write-Host "Version updated successfully"
      shell: pwsh
      if: startsWith(github.ref, 'refs/tags/v')
      
    - name: Build solution
      run: |
          msbuild /p:Configuration=${{ env.Configuration }} `
            /p:Platform="${{ env.Platform }}" `
            /p:AppxPackageDir="AppPackages\" `
            /p:AppxBundle=Always `
            /p:UapAppxPackageBuildMode=StoreUpload `
            /p:AppxBundlePlatforms="${{ env.Platform }}" `
            /p:GenerateAppxPackageOnBuild=true `
            /p:SelfContained=true `
            ${{ env.Solution_Name }}
                
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          # Verify that MSIX package was created
          $msixCount = (Get-ChildItem -Path "AppPackages\" -Filter "*.msix*" -Recurse).Count
          Write-Host "Found $msixCount MSIX package(s) in output directory"
          if ($msixCount -eq 0) {
            Write-Error "No MSIX packages were generated during build"
            exit 1
          }
      shell: pwsh
      
    - name: Create MSI installer with Advanced Installer
      run: |
        # Install Advanced Installer CLI
        Write-Host "Installing Advanced Installer via Chocolatey"
        choco install advanced-installer -y
        
        # Refresh environment variables
        refreshenv
        
        # Find the correct executable (AdvancedInstaller.com, not advinst.exe)
        $advinstPath = "C:\Program Files (x86)\Caphyon\Advanced Installer 22.5\bin\x86\AdvancedInstaller.com"
        
        Write-Host "Checking for Advanced Installer at: $advinstPath"
        if (-not (Test-Path $advinstPath)) {
          Write-Host "Searching for Advanced Installer executable..."
          $possiblePaths = Get-ChildItem -Path "C:\Program Files (x86)" -Recurse -Filter "AdvancedInstaller.com" -ErrorAction SilentlyContinue
          if ($possiblePaths) {
            $advinstPath = $possiblePaths[0].FullName
          } else {
            Write-Error "Could not find Advanced Installer executable"
            exit 1
          }
        }
        
        Write-Host "Found Advanced Installer at: $advinstPath"
        
        # Get version from tag
        $version = "${{ github.ref_name }}"
        if (-not $version -or $version -eq '') { $version = "1.0.0" }
        if ($version.StartsWith('v')) { $version = $version.Substring(1) }
        
        # Find the MSIX package
        $msixPath = Get-ChildItem -Path "AppPackages\" -Filter "*.msix" -Recurse | Select-Object -First 1 -ExpandProperty FullName
        if (-not $msixPath) {
          Write-Error "No MSIX package found in build output"
          exit 1
        }
        
        # Create a new Advanced Installer project of type msix_to_msi
        Write-Host "Creating Advanced Installer project"
        & $advinstPath /newproject "installer.aip" -packagetype "msix_to_msi"
        
        # Set project properties
        & $advinstPath /edit "installer.aip" /SetProperty ProductName="Code File Splitter"
        & $advinstPath /edit "installer.aip" /SetProperty Manufacturer="Your Company"
        & $advinstPath /edit "installer.aip" /SetProperty Version="$version"
        
        # Add MSIX package to project
        Write-Host "Adding MSIX package: $msixPath"
        & $advinstPath /edit "installer.aip" /AddMsix "$msixPath"
        
        # Build the project
        Write-Host "Building MSI"
        & $advinstPath /build "installer.aip"
        
        # Copy the resulting MSI to expected location
        $msiPath = "MSI\CodeFileSplitter.msi"
        if (Test-Path $msiPath) {
          $targetPath = "CodeFileSplitter-$version.msi"
          Copy-Item $msiPath $targetPath
          Write-Host "MSI created successfully at: $targetPath"
        } else {
          Write-Host "Looking for MSI in output directory..."
          $msiFiles = Get-ChildItem -Path "MSI\" -Filter "*.msi" -Recurse
          if ($msiFiles) {
            $sourcePath = $msiFiles[0].FullName
            $targetPath = "CodeFileSplitter-$version.msi"
            Copy-Item $sourcePath $targetPath
            Write-Host "MSI created and copied to: $targetPath"
          } else {
            Write-Error "No MSI files found in output directory"
            exit 1
          }
        }
      shell: pwsh
      
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        name: Code File Splitter ${{ github.ref_name }}
        files: CodeFileSplitter-*.msi
        draft: false
        prerelease: false
        generate_release_notes: true
      if: startsWith(github.ref, 'refs/tags/')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
