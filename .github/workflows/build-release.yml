name: Build and Release
on:
  push:
    tags:
      - 'v*.*.*'  # Run only when a tag is pushed with semantic versioning format
  workflow_dispatch:  # Allow manual dispatch

jobs:
  build:
    runs-on: windows-latest
    
    env:
      Solution_Name: CodeSplitter.sln
      Configuration: Release
      Platform: x64
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags and branches
        
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup MSBuild Path
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows SDK
      uses: GuillaumeFalourd/setup-windows10-sdk-action@v1
      with:
        sdk-version: 22621
        
    - name: Install Windows App SDK
      run: |
        # Using Windows App SDK version from project file
        $windowsAppSdkUrl = "https://aka.ms/windowsappsdk/1.6/1.6.250205002/windowsappruntimeinstall-x64.exe"
        $installerPath = "windowsappruntimeinstall-x64.exe"
        
        Write-Host "Downloading Windows App SDK from $windowsAppSdkUrl"
        $WebClient = New-Object System.Net.WebClient
        $WebClient.DownloadFile($windowsAppSdkUrl, $installerPath)
        
        Write-Host "Installing Windows App SDK"
        $process = Start-Process -FilePath $installerPath -ArgumentList "--quiet" -Wait -PassThru
        if ($process.ExitCode -ne 0) {
          Write-Error "Windows App SDK installation failed with exit code $($process.ExitCode)"
          exit 1
        }
        Write-Host "Windows App SDK installed successfully"
      shell: pwsh
      
    - name: Restore NuGet packages
      run: |
        Write-Host "Restoring NuGet packages for ${{ env.Solution_Name }}"
        nuget restore ${{ env.Solution_Name }}
        if ($LASTEXITCODE -ne 0) {
          Write-Error "NuGet restore failed with exit code $LASTEXITCODE"
          exit 1
        }
      shell: pwsh
      
    - name: Set Version Number in AppxManifest
      run: |
        $tag = "${{ github.ref_name }}"
        # Remove 'v' prefix if present
        if ($tag.StartsWith('v')) {
          $tag = $tag.Substring(1)
        }
        
        $manifestPath = "Package.appxmanifest"
        Write-Host "Setting version to $tag.0 in $manifestPath"
        
        if (-not (Test-Path $manifestPath)) {
          Write-Error "AppxManifest file not found at $manifestPath"
          exit 1
        }
        
        $manifest = [xml](Get-Content $manifestPath)
        $manifest.Package.Identity.Version = "$tag.0"
        $manifest.Save($manifestPath)
        
        Write-Host "Version updated successfully"
      shell: pwsh
      if: startsWith(github.ref, 'refs/tags/v')
      
    - name: Build solution
      run: |
          msbuild /p:Configuration=${{ env.Configuration }} `
            /p:Platform="${{ env.Platform }}" `
            /p:AppxPackageDir="AppPackages\" `
            /p:AppxBundle=Always `
            /p:UapAppxPackageBuildMode=StoreUpload `
            /p:AppxBundlePlatforms="${{ env.Platform }}" `
            /p:GenerateAppxPackageOnBuild=true `
            /p:SelfContained=true `
            ${{ env.Solution_Name }}
                
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          # Verify that MSIX package was created
          $msixCount = (Get-ChildItem -Path "AppPackages\" -Filter "*.msix*" -Recurse).Count
          Write-Host "Found $msixCount MSIX package(s) in output directory"
          if ($msixCount -eq 0) {
            Write-Error "No MSIX packages were generated during build"
            exit 1
          }
      shell: pwsh
      
    - name: Create MSI installer with Advanced Installer
      run: |
        # Install Advanced Installer CLI
        Write-Host "Installing Advanced Installer via Chocolatey"
        choco install advanced-installer -y
        
        # Refresh environment variables
        refreshenv
        
        # Find the correct executable
        $advinstPath = "C:\Program Files (x86)\Caphyon\Advanced Installer 22.5\bin\x86\AdvancedInstaller.com"
        
        Write-Host "Checking for Advanced Installer at: $advinstPath"
        if (-not (Test-Path $advinstPath)) {
          Write-Host "Searching for Advanced Installer executable..."
          $possiblePaths = Get-ChildItem -Path "C:\Program Files (x86)" -Recurse -Filter "AdvancedInstaller.com" -ErrorAction SilentlyContinue
          if ($possiblePaths) {
            $advinstPath = $possiblePaths[0].FullName
          } else {
            Write-Error "Could not find Advanced Installer executable"
            exit 1
          }
        }
        
        Write-Host "Found Advanced Installer at: $advinstPath"
        
        # Get version from tag
        $version = "${{ github.ref_name }}"
        if (-not $version -or $version -eq '') { $version = "1.0.0" }
        if ($version.StartsWith('v')) { $version = $version.Substring(1) }
        
        # Find the MSIX package
        $msixPath = Get-ChildItem -Path "AppPackages\" -Filter "*.msix" -Recurse | Select-Object -First 1 -ExpandProperty FullName
        if (-not $msixPath) {
          Write-Error "No MSIX package found in build output"
          exit 1
        }
        
        # Extract the MSIX package
        $extractDir = "MSIXExtracted"
        New-Item -ItemType Directory -Path $extractDir -Force
        
        # Use Expand-Archive if the MSIX is actually a ZIP (which it should be internally)
        try {
          Write-Host "Extracting MSIX package to $extractDir"
          Expand-Archive -Path $msixPath -DestinationPath $extractDir -Force
        } catch {
          Write-Host "Standard extraction failed, trying alternative method..."
          # If that fails, try using 7zip which comes with GitHub Actions runners
          & 7z x -o"$extractDir" "$msixPath"
        }
        
        # Create output directory
        $msiDir = "MSI"
        New-Item -ItemType Directory -Path $msiDir -Force
        
        # Create a new simple Advanced Installer project
        Write-Host "Creating Advanced Installer project"
        & $advinstPath /newproject "installer.aip"
        
        # Set product properties
        & $advinstPath /edit "installer.aip" /SetProperty ProductName="Code File Splitter"
        & $advinstPath /edit "installer.aip" /SetProperty Manufacturer="Your Company"
        & $advinstPath /edit "installer.aip" /SetProperty Version="$version"
        
        # Add the extracted files to the project
        Write-Host "Adding files from extracted MSIX to the project"
        if (Test-Path $extractDir) {
          # Add all extracted files to the project
          & $advinstPath /edit "installer.aip" /AddFolder "$extractDir"
          
          # Get AppxManifest.xml to extract more information if needed
          $manifestPath = Join-Path -Path $extractDir -ChildPath "AppxManifest.xml"
          if (Test-Path $manifestPath) {
            Write-Host "Found AppxManifest.xml, extracting info"
            $manifest = [xml](Get-Content $manifestPath)
            $appId = $manifest.Package.Identity.Name
            Write-Host "App ID: $appId"
            
            # Set more properties based on the manifest if needed
            & $advinstPath /edit "installer.aip" /SetProperty ProductName="$appId"
          }
        } else {
          Write-Error "Failed to extract MSIX package"
          exit 1
        }
        
        # Set output directory
        $fullMsiDir = Join-Path -Path (Get-Location) -ChildPath $msiDir
        & $advinstPath /edit "installer.aip" /SetOutputLocation -buildname "DefaultBuild" -path "$fullMsiDir"
        
        # Build the project
        Write-Host "Building MSI"
        & $advinstPath /build "installer.aip"
        
        # Look for MSI files in multiple locations
        $targetPath = "CodeFileSplitter-$version.msi"
        $msiFound = $false
        
        # List all files in current directory and subdirectories to debug
        Write-Host "Files in workspace:"
        Get-ChildItem -Path "." -Recurse -Include "*.msi", "*.exe", "*.aip" | Format-Table FullName
        
        # Check in specified MSI directory first
        if (Test-Path $msiDir) {
          Write-Host "Looking for MSI in $msiDir directory..."
          $msiFiles = Get-ChildItem -Path $msiDir -Filter "*.msi" -ErrorAction SilentlyContinue
          if ($msiFiles) {
            $sourcePath = $msiFiles[0].FullName
            Copy-Item $sourcePath $targetPath
            Write-Host "MSI found and copied to: $targetPath"
            $msiFound = $true
          }
        }
        
        # If not found, search in current directory and subdirectories
        if (-not $msiFound) {
          Write-Host "Looking for MSI files in current directory and subdirectories..."
          $msiFiles = Get-ChildItem -Path "." -Filter "*.msi" -Recurse -ErrorAction SilentlyContinue
          if ($msiFiles) {
            $sourcePath = $msiFiles[0].FullName
            Copy-Item $sourcePath $targetPath -Force
            Write-Host "MSI found and copied to: $targetPath"
            $msiFound = $true
          } else {
            Write-Error "No MSI files found in output directories"
            exit 1
          }
        }
      shell: pwsh
      
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        name: Code File Splitter ${{ github.ref_name }}
        files: CodeFileSplitter-*.msi
        draft: false
        prerelease: false
        generate_release_notes: true
      if: startsWith(github.ref, 'refs/tags/')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
