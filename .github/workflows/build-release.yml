name: Build and Release
on:
  push:
    tags:
      - 'v*.*.*'  # Run only when a tag is pushed with semantic versioning format
  workflow_dispatch:  # Allow manual dispatch

jobs:
  build:
    strategy:
      matrix:
        configuration: [Release]
        platform: [x64]  # You can add x86 if needed

    runs-on: windows-latest
    
    env:
      Solution_Name: CodeSplitter.sln
      Configuration: ${{ matrix.configuration }}
      Platform: ${{ matrix.platform }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags and branches
        
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup MSBuild Path
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows SDK
      uses: GuillaumeFalourd/setup-windows10-sdk-action@v1
      with:
        sdk-version: 22621
        
    - name: Install Windows App SDK
      run: |
        # Using Windows App SDK version from project file
        $windowsAppSdkUrl = "https://aka.ms/windowsappsdk/1.6/1.6.250205002/windowsappruntimeinstall-x64.exe"
        $installerPath = "windowsappruntimeinstall-x64.exe"
        
        Write-Host "Downloading Windows App SDK from $windowsAppSdkUrl"
        $WebClient = New-Object System.Net.WebClient
        $WebClient.DownloadFile($windowsAppSdkUrl, $installerPath)
        
        Write-Host "Installing Windows App SDK"
        $process = Start-Process -FilePath $installerPath -ArgumentList "--quiet" -Wait -PassThru
        if ($process.ExitCode -ne 0) {
          Write-Error "Windows App SDK installation failed with exit code $($process.ExitCode)"
          exit 1
        }
        Write-Host "Windows App SDK installed successfully"
      shell: pwsh
      
    - name: Restore NuGet packages
      run: |
        Write-Host "Restoring NuGet packages for ${{ env.Solution_Name }}"
        nuget restore ${{ env.Solution_Name }}
        if ($LASTEXITCODE -ne 0) {
          Write-Error "NuGet restore failed with exit code $LASTEXITCODE"
          exit 1
        }
      shell: pwsh
      
    - name: Set Version Number in AppxManifest
      run: |
        $tag = "${{ github.ref_name }}"
        # Remove 'v' prefix if present
        if ($tag.StartsWith('v')) {
          $tag = $tag.Substring(1)
        }
        
        $manifestPath = "Package.appxmanifest"
        Write-Host "Setting version to $tag.0 in $manifestPath"
        
        if (-not (Test-Path $manifestPath)) {
          Write-Error "AppxManifest file not found at $manifestPath"
          exit 1
        }
        
        $manifest = [xml](Get-Content $manifestPath)
        $manifest.Package.Identity.Version = "$tag.0"
        $manifest.Save($manifestPath)
        
        Write-Host "Version updated successfully"
      shell: pwsh
      if: startsWith(github.ref, 'refs/tags/v')
      
    # Generate a test certificate if no certificate is provided
    - name: Create or use certificate
      run: |
        # Check if the BASE64_ENCODED_PFX secret exists
        if ("${{ secrets.BASE64_ENCODED_PFX }}" -ne "") {
          Write-Host "Using provided certificate"
          $pfx_cert_byte = [System.Convert]::FromBase64String("${{ secrets.BASE64_ENCODED_PFX }}")
          $certificatePath = "GitHubActionsWorkflow.pfx"
          [IO.File]::WriteAllBytes("$certificatePath", $pfx_cert_byte)
        } else {
          Write-Host "Creating test certificate"
          # Create a new self-signed certificate
          $cert = New-SelfSignedCertificate -Type Custom -Subject "CN=YourCompanyName" -KeyUsage DigitalSignature -FriendlyName "Your App Certificate" -CertStoreLocation "Cert:\CurrentUser\My" -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.3", "2.5.29.19={text}")
          
          # Export the certificate with a password
          $password = ConvertTo-SecureString -String "YourPassword" -Force -AsPlainText
          $certPath = "GitHubActionsWorkflow.pfx"
          Export-PfxCertificate -Cert $cert -FilePath $certPath -Password $password
          
          # Also export the public certificate that users will need to install
          Export-Certificate -Cert $cert -FilePath "AppCertificate.cer" -Type CERT
          
          # Set environment variable for build step
          echo "CERT_PASSWORD=YourPassword" >> $env:GITHUB_ENV
        }
      shell: pwsh
      
    - name: Build solution
      run: |
        if (Test-Path env:CERT_PASSWORD) {
          # If using generated cert with password
          msbuild ${{ env.Solution_Name }} `
            /p:Configuration=${{ env.Configuration }} `
            /p:Platform="${{ env.Platform }}" `
            /p:AppxPackageDir="AppPackages\" `
            /p:AppxBundle=Always `
            /p:UapAppxPackageBuildMode=StoreAndSideload `
            /p:AppxBundlePlatforms="${{ env.Platform }}" `
            /p:PackageCertificateKeyFile=GitHubActionsWorkflow.pfx `
            /p:PackageCertificatePassword=$env:CERT_PASSWORD `
            /p:GenerateAppxPackageOnBuild=true
        } else {
          # If using provided cert without password
          msbuild ${{ env.Solution_Name }} `
            /p:Configuration=${{ env.Configuration }} `
            /p:Platform="${{ env.Platform }}" `
            /p:AppxPackageDir="AppPackages\" `
            /p:AppxBundle=Always `
            /p:UapAppxPackageBuildMode=StoreAndSideload `
            /p:AppxBundlePlatforms="${{ env.Platform }}" `
            /p:PackageCertificateKeyFile=GitHubActionsWorkflow.pfx `
            /p:GenerateAppxPackageOnBuild=true
        }
                
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Build failed with exit code $LASTEXITCODE"
          exit 1
        }
          
        # Verify that MSIX package was created
        $msixCount = (Get-ChildItem -Path "AppPackages\" -Filter "*.msix*" -Recurse).Count
        Write-Host "Found $msixCount MSIX package(s) in output directory"
        if ($msixCount -eq 0) {
          Write-Error "No MSIX packages were generated during build"
          exit 1
        }
      shell: pwsh

    # Remove the pfx
    - name: Remove the pfx
      run: Remove-Item -path GitHubActionsWorkflow.pfx
      shell: pwsh

    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Upload MSIX package
      uses: actions/upload-artifact@v3
      with:
        name: MSIX Package
        path: AppPackages/
        
    - name: Upload Certificate
      uses: actions/upload-artifact@v3
      with:
        name: Certificate
        path: AppCertificate.cer
      if: hashFiles('AppCertificate.cer') != ''
      
    # Install WiX Toolset
    - name: Install WiX Toolset
      run: |
        Write-Host "Installing WiX Toolset..."
        choco install wixtoolset -y
        refreshenv
      shell: pwsh
      
    # Create MSI installer with WiX Toolset
    - name: Create MSI installer
      run: |
        # Get version from tag
        $version = "${{ github.ref_name }}"
        if (-not $version -or $version -eq '') { $version = "1.0.0" }
        if ($version.StartsWith('v')) { $version = $version.Substring(1) }
        
        # Create folder for installer files
        $installerDir = "InstallerFiles"
        New-Item -ItemType Directory -Path $installerDir -Force
        
        # Get main executable path
        $exePath = Get-ChildItem -Path "${{ env.Platform }}\${{ env.Configuration }}" -Filter "*.exe" | Select-Object -First 1 -ExpandProperty FullName
        if (-not $exePath) {
          Write-Error "Could not find the main executable"
          exit 1
        }
        $exeName = [System.IO.Path]::GetFileName($exePath)
        Write-Host "Found main executable: $exeName"
        
        # Create WiX source file
        $wxsContent = @"
        <?xml version="1.0" encoding="UTF-8"?>
        <Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
          <Product Id="*" 
                   Name="Code File Splitter" 
                   Language="1033" 
                   Version="$version" 
                   Manufacturer="Your Company" 
                   UpgradeCode="PUT-GUID-HERE">
            
            <Package InstallerVersion="200" Compressed="yes" InstallScope="perMachine" />
            
            <MajorUpgrade DowngradeErrorMessage="A newer version of Code File Splitter is already installed." />
            <MediaTemplate EmbedCab="yes" />
            
            <Feature Id="ProductFeature" Title="Code File Splitter" Level="1">
              <ComponentGroupRef Id="ProductComponents" />
              <ComponentRef Id="ApplicationShortcut" />
            </Feature>
            
            <Property Id="WIXUI_INSTALLDIR" Value="INSTALLFOLDER" />
            <UIRef Id="WixUI_InstallDir" />
            <WixVariable Id="WixUILicenseRtf" Value="license.rtf" />
            
            <Directory Id="TARGETDIR" Name="SourceDir">
              <Directory Id="ProgramFilesFolder">
                <Directory Id="INSTALLFOLDER" Name="CodeFileSplitter">
                  <!-- Components will be added here -->
                </Directory>
              </Directory>
              <Directory Id="ProgramMenuFolder">
                <Directory Id="ApplicationProgramsFolder" Name="Code File Splitter"/>
              </Directory>
            </Directory>
            
            <ComponentGroup Id="ProductComponents" Directory="INSTALLFOLDER">
              <!-- Components will be added here dynamically -->
            </ComponentGroup>
            
            <DirectoryRef Id="ApplicationProgramsFolder">
              <Component Id="ApplicationShortcut" Guid="*">
                <Shortcut Id="ApplicationStartMenuShortcut" 
                          Name="Code File Splitter" 
                          Description="Split code files by class or function"
                          Target="[INSTALLFOLDER]$exeName"
                          WorkingDirectory="INSTALLFOLDER"/>
                <RemoveFolder Id="CleanUpShortCut" Directory="ApplicationProgramsFolder" On="uninstall"/>
                <RegistryValue Root="HKCU" Key="Software\CodeFileSplitter" Name="installed" Type="integer" Value="1" KeyPath="yes"/>
              </Component>
            </DirectoryRef>
          </Product>
        </Wix>
        "@
                
                # Create a temporary license file
                $licenseContent = @"
        {\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
        {\*\generator Riched20 10.0.19041}\viewkind4\uc1 
        \pard\sa200\sl276\slmult1\f0\fs22\lang9 Sample License for Code File Splitter\par
        \par
        This is a placeholder license. Replace with your actual license text.\par
        }
        "@
                
                # Save the WiX source file and license
                Set-Content -Path "installer.wxs" -Value $wxsContent
                Set-Content -Path "license.rtf" -Value $licenseContent
                
                # Gather files for the installer
                Write-Host "Gathering build output files..."
                
                # Get binaries from the build output
                $binDir = "${{ env.Platform }}\${{ env.Configuration }}"
                if (Test-Path $binDir) {
                  # Get all files from bin directory
                  $files = Get-ChildItem -Path $binDir -Recurse -File | Where-Object { -not $_.FullName.Contains("AppX") }
                  
                  # Create component entries in WXS file
                  $componentXml = ""
                  foreach ($file in $files) {
                    $fileName = [System.IO.Path]::GetFileName($file.FullName)
                    $fileId = $fileName.Replace(".", "_").Replace(" ", "_").Replace("-", "_")
                    $componentXml += "<Component Id='Component_$fileId' Guid='*'>`n"
                    $componentXml += "  <File Id='File_$fileId' Source='$($file.FullName)' KeyPath='yes'/>`n"
                    $componentXml += "</Component>`n"
                  }
                  
                  # Update the WXS file with dynamic components
                  $wxsContent = $wxsContent -replace "<ComponentGroup Id=""ProductComponents"" Directory=""INSTALLFOLDER"">(\s+)<!-- Components will be added here dynamically -->", "<ComponentGroup Id=""ProductComponents"" Directory=""INSTALLFOLDER"">`n$componentXml"
                  Set-Content -Path "installer.wxs" -Value $wxsContent
                } else {
                  Write-Error "Build output directory not found: $binDir"
                  exit 1
                }
                
                # Set GUID for UpgradeCode
                $upgradeGuid = [Guid]::NewGuid().ToString("B").ToUpper()
                (Get-Content "installer.wxs") -replace "PUT-GUID-HERE", $upgradeGuid | Set-Content "installer.wxs"
                
                # Compile and link the installer
                Write-Host "Compiling WiX installer..."
                & candle.exe -arch x64 installer.wxs
                if ($LASTEXITCODE -ne 0) {
                  Write-Error "WiX candle compilation failed with exit code $LASTEXITCODE"
                  exit 1
                }
                
                # Link to create MSI
                $msiName = "CodeFileSplitter-$version.msi"
                Write-Host "Linking WiX installer to $msiName..."
                & light.exe -ext WixUIExtension installer.wixobj -out $msiName
                if ($LASTEXITCODE -ne 0) {
                  Write-Error "WiX light linking failed with exit code $LASTEXITCODE"
                  exit 1
                }
                
                # Verify MSI was created
                if (Test-Path $msiName) {
                  Write-Host "MSI installer created successfully: $msiName"
                } else {
                  Write-Error "Failed to create MSI installer"
                  exit 1
                }
      shell: pwsh
        
    - name: Upload MSI artifact
      uses: actions/upload-artifact@v4
      with:
        name: MSI Installer
        path: CodeFileSplitter-*.msi
        
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        name: Code File Splitter ${{ github.ref_name }}
        files: |
          CodeFileSplitter-*.msi
          AppPackages/**/*.msixbundle
          AppCertificate.cer
        draft: false
        prerelease: false
        generate_release_notes: true
      if: startsWith(github.ref, 'refs/tags/')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
