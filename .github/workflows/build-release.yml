name: Build and Release
on:
  push:
    tags:
      - 'v*.*.*'  # Run only when a tag is pushed with semantic versioning format
  workflow_dispatch:  # Allow manual dispatch

jobs:
  build:
    runs-on: windows-latest
    
    env:
      Solution_Name: CodeSplitter.sln
      Configuration: Release
      Platform: x64
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags and branches
        
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
        
    - name: Setup MSBuild Path
      uses: microsoft/setup-msbuild@v1.3
      
    - name: Setup Windows SDK
      uses: GuillaumeFalourd/setup-windows10-sdk-action@v1
      with:
        sdk-version: 22621
        
    - name: Install Windows App SDK
      run: |
        # Using Windows App SDK version from project file
        $windowsAppSdkUrl = "https://aka.ms/windowsappsdk/1.6/1.6.250205002/windowsappruntimeinstall-x64.exe"
        $installerPath = "windowsappruntimeinstall-x64.exe"
        
        Write-Host "Downloading Windows App SDK from $windowsAppSdkUrl"
        $WebClient = New-Object System.Net.WebClient
        $WebClient.DownloadFile($windowsAppSdkUrl, $installerPath)
        
        Write-Host "Installing Windows App SDK"
        $process = Start-Process -FilePath $installerPath -ArgumentList "--quiet" -Wait -PassThru
        if ($process.ExitCode -ne 0) {
          Write-Error "Windows App SDK installation failed with exit code $($process.ExitCode)"
          exit 1
        }
        Write-Host "Windows App SDK installed successfully"
      shell: pwsh
      
    - name: Restore NuGet packages
      run: |
        Write-Host "Restoring NuGet packages for ${{ env.Solution_Name }}"
        nuget restore ${{ env.Solution_Name }}
        if ($LASTEXITCODE -ne 0) {
          Write-Error "NuGet restore failed with exit code $LASTEXITCODE"
          exit 1
        }
      shell: pwsh
      
    - name: Set Version Number in AppxManifest
      run: |
        $tag = "${{ github.ref_name }}"
        # Remove 'v' prefix if present
        if ($tag.StartsWith('v')) {
          $tag = $tag.Substring(1)
        }
        
        $manifestPath = "Package.appxmanifest"
        Write-Host "Setting version to $tag.0 in $manifestPath"
        
        if (-not (Test-Path $manifestPath)) {
          Write-Error "AppxManifest file not found at $manifestPath"
          exit 1
        }
        
        $manifest = [xml](Get-Content $manifestPath)
        $manifest.Package.Identity.Version = "$tag.0"
        $manifest.Save($manifestPath)
        
        Write-Host "Version updated successfully"
      shell: pwsh
      if: startsWith(github.ref, 'refs/tags/v')
      
    - name: Build solution
      run: |
          msbuild /p:Configuration=${{ env.Configuration }} `
            /p:Platform="${{ env.Platform }}" `
            /p:AppxPackageDir="AppPackages\" `
            /p:AppxBundle=Always `
            /p:UapAppxPackageBuildMode=StoreUpload `
            /p:AppxBundlePlatforms="${{ env.Platform }}" `
            /p:GenerateAppxPackageOnBuild=true `
            /p:SelfContained=true `
            ${{ env.Solution_Name }}
                
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          # Verify that MSIX package was created
          $msixCount = (Get-ChildItem -Path "AppPackages\" -Filter "*.msix*" -Recurse).Count
          Write-Host "Found $msixCount MSIX package(s) in output directory"
          if ($msixCount -eq 0) {
            Write-Error "No MSIX packages were generated during build"
            exit 1
          }
      shell: pwsh
      
    - name: Create MSI installer with Advanced Installer
      run: |
        # Install Advanced Installer CLI
        Write-Host "Installing Advanced Installer via Chocolatey"
        choco install advanced-installer -y
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to install Advanced Installer"
          exit 1
        }

        Import-Module $env:ChocolateyInstall\helpers\chocolateyProfile.psm1
        
        # Get version from tag or use default
        $version = "${{ github.ref_name }}"
        if (-not $version -or $version -eq '') {
          $version = "1.0.0"
        }
        if ($version.StartsWith('v')) {
          $version = $version.Substring(1)
        }
        
        Write-Host "Creating Advanced Installer project for version $version"
        
        # Create a simple Advanced Installer project
        advancedinstaller.com /newproject installer.aip -packagetype msix_to_msi
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to create Advanced Installer project"
          exit 1
        }
        
        # Set project properties
        advancedinstaller.com /edit installer.aip /SetProperty ProductName="Code File Splitter"
        advancedinstaller.com /edit installer.aip /SetProperty Manufacturer="GG"
        advancedinstaller.com /edit installer.aip /SetProperty Version="$version"
        
        # Find the MSIX package in the build output
        $msixPath = Get-ChildItem -Path "AppPackages\" -Filter "*.msix" -Recurse | Select-Object -First 1 -ExpandProperty FullName
        if (-not $msixPath) {
          Write-Error "No MSIX package found in build output"
          exit 1
        }
        Write-Host "Found MSIX package at: $msixPath"
        
        # Add the MSIX package to the project
        Write-Host "Adding MSIX package to Advanced Installer project"
        advancedinstaller.com /edit installer.aip /AddMsix "$msixPath"
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to add MSIX to Advanced Installer project"
          exit 1
        }
        
        # Build the MSI
        Write-Host "Building MSI installer"
        advancedinstaller.com /build installer.aip
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to build MSI"
          exit 1
        }
        
        # Check if MSI was created and determine its path
        $msiFiles = Get-ChildItem -Path ".\MSI\" -Filter "*.msi" -Recurse
        if (-not $msiFiles -or $msiFiles.Count -eq 0) {
          Write-Error "MSI file not found in expected output directory"
          exit 1
        }
        
        $msiPath = $msiFiles[0].FullName
        Write-Host "MSI created at: $msiPath"
        
        # Move the MSI to the root directory with version in filename
        $targetMsiPath = ".\CodeFileSplitter-$version.msi"
        Write-Host "Copying MSI to: $targetMsiPath"
        Copy-Item $msiPath $targetMsiPath
        
        if (-not (Test-Path $targetMsiPath)) {
          Write-Error "Failed to copy MSI file to target location"
          exit 1
        }
        
        Write-Host "MSI installer created successfully: $targetMsiPath"
      shell: pwsh
      
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        name: Code File Splitter ${{ github.ref_name }}
        files: CodeFileSplitter-*.msi
        draft: false
        prerelease: false
        generate_release_notes: true
      if: startsWith(github.ref, 'refs/tags/')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
